# Data Generation Patterns & Dependencies Analysis

## Overview
This document provides a comprehensive guide to understand the structure, types, and dependencies in the API Data Generators project. It explains how different entities relate to each other and what dependencies are required when creating test data.

---

## 1. Generator Types

### 1.1 STATIC Type
**Definition**: Fixed, hardcoded values that don't change.

**Use Case**: Constants, enumerations, default values that remain the same across all test runs.

**Example**:
```json
"addFeedback_listAllArticles_sortBy": [{
  "type": "static",
  "value": ["createdTime"]
}]
```

**Characteristics**:
- Simple to understand
- No API calls required
- Same value every time
- Used for configurations, permissions, statuses, etc.

---

### 1.2 DYNAMIC Type
**Definition**: Values generated by calling actual APIs and extracting data from responses.

**Use Case**: Creating test data that depends on existing entities (IDs, real data from database).

**Example**:
```json
"articleId": [{
  "type": "dynamic",
  "generatorOperationId": "Solution.listAllArticles",
  "dataPath": "$.response.body:$.data[*].id",
  "params": {
    "sortBy": "$generators:#/generators/addFeedback_listAllArticles_sortBy"
  }
}]
```

**Key Components**:
- `generatorOperationId`: Which API operation to call (format: `Namespace.APIName.operation`)
- `dataPath`: JSON path to extract data from API response
- `params`: Input parameters for the API call (can reference other generators)
- `name`: Optional name for the generated data (for reference in subsequent generators)

---

## 2. Dependency Model

### 2.1 Simple Linear Dependency (Book Borrow Example)
```
Customer (Static) → Book Entity (Dynamic) → Book-Customer Link (Dynamic)
```

**Real Example - Article Feedback Flow**:
```
1. STATIC: locale = ["en"]
2. DYNAMIC: articleId = Call Solution.listAllArticles() → Get article IDs
3. DYNAMIC: feedbackId = Call ArticleFeedback.addFeedback(articleId, locale)
```

### 2.2 Cross-Namespace Dependencies
Files can reference generators from **other modules** using relative paths.

**Pattern**: `"../ModuleName/test_data_generation_configurations.json#/generators/generator_name"`

**Real Example**:
```json
{
  "departmentId": "../Department/test_data_generation_configurations.json#/generators/department_id",
  "agentIds": "../Agent/test_data_generation_configurations.json#/generators/agent_id"
}
```

This means:
- Ticket depends on Department (must exist first)
- Ticket depends on Agent (must exist first)
- Department and Agent are independent of Ticket

---

## 3. Folder Structure & Organization

### 3.1 Portal vs Support
```
api-data-generators/
├── portal/                 # Customer-facing features
│   ├── ArticleFeedback/
│   ├── Solution/
│   ├── Category/
│   └── ... (Customer knowledge base features)
│
└── support/               # Internal support system
    ├── Ticket/
    ├── Agent/
    ├── Department/
    ├── Contact/
    └── ... (Support management features)
```

**Key Insight**: Portal features often depend on Support entities.

---

## 4. Common Dependency Patterns

### Pattern 1: Parent-Child Relationship
```
Parent Entity (Independent) 
    ↓
Child Entity (Depends on Parent ID)

Example:
Category (Static/Independent)
    ↓
Article (Needs categoryId from Category)
    ↓
ArticleComment (Needs articleId from Article)
```

### Pattern 2: Cross-Entity References
```
Entity A ←── Entity B
Entity A ←── Entity C

Example:
Ticket ←── Agent (assignee)
Ticket ←── Department (belongs to)
Ticket ←── Contact (created by)
```

### Pattern 3: Chained Dynamic Dependencies
```
Static Value
    ↓
Dynamic Generator 1 (Uses Static Value)
    ↓
Dynamic Generator 2 (Uses output from Generator 1)
    ↓
API Call (Uses output from Generator 2)
```

**Real Example**:
```json
// Generator 1: Static sort parameter
"listAllArticles_sortBy": [{
  "type": "static",
  "value": ["createdTime"]
}]

// Generator 2: Dynamic - list articles using sort parameter
"articleId": [{
  "type": "dynamic",
  "generatorOperationId": "Solution.listAllArticles",
  "params": {
    "sortBy": "$generators:#/generators/listAllArticles_sortBy"  ← References Generator 1
  }
}]

// Generator 3: Dynamic - create feedback using articleId
"feedbackId": [{
  "type": "dynamic",
  "generatorOperationId": "ArticleFeedback.addFeedback",
  "params": {
    "articleId": "$articles.value"  ← References Generator 2
  }
}]
```

---

## 5. Reference Patterns

### 5.1 Generator Reference
**Syntax**: `$generators:#/generators/generator_name`

**Usage**: When a generator needs to use another generator's output as input.

**Example**:
```json
"params": {
  "sortBy": "$generators:#/generators/listAllArticles_sortBy"
}
```

### 5.2 Generator Value Reference
**Syntax**: `$generator_name.value`

**Usage**: When you need the actual output value from a previously executed generator.

**Example**:
```json
"params": {
  "articleId": "$articles.value"  // 'articles' is the name from previous generator
}
```

### 5.3 Input Path Reference
**Syntax**: `$.input.path:$.field_name`

**Usage**: Extracting values from the current API call's input parameters.

**Example**:
```json
"params": {
  "articleId": "$.input.path:$.entityId"  // Get entityId from current request path
}
```

### 5.4 Cross-Module Reference
**Syntax**: `"../ModuleName/test_data_generation_configurations.json#/generators/generator_name"`

**Usage**: Using generators from other modules.

**Example**:
```json
"departmentId": "../Department/test_data_generation_configurations.json#/generators/department_id"
```

---

## 6. Data Path Extraction Syntax

### DataPath Pattern: `$.response.body:$.path.to.data`

**Components**:
- `$.response.body` - Navigate to response body
- `:` - Separator
- `$.path.to.data` - JSON path to extract data

**Examples**:
```json
// Get all article IDs from array
"dataPath": "$.response.body:$.data[*].id"

// Get single ID from response
"dataPath": "$.response.body:$.id"

// Get locale from specific location
"dataPath": "$.response.body:$.locales[*].locale"

// Get nested field
"dataPath": "$.response.body:$.article.metadata.id"
```

---

## 7. Real-World Dependency Examples

### Example 1: Simple Ticket Creation
```
Ticket Creation Flow:
1. Static Values (independent)
   - status: "Open"
   - priority: "High"

2. Dynamic Dependencies (must be created first):
   - agentId ← Agent.getAgents() 
   - departmentId ← Department.getDepartments()
   - contactId ← Contact.getContacts()

3. API Call (depends on all above):
   - Ticket.createTicket(agentId, departmentId, contactId, status, priority)
```

### Example 2: Article Feedback with Comments
```
Flow:
1. Static:
   - locale = "en"
   - sortBy = "createdTime"

2. Dynamic Level 1:
   - articleId = Solution.listAllArticles(sortBy=sortBy)

3. Dynamic Level 2:
   - commentId = ArticleComment.addArticleTranslationComment(articleId=articleId)

4. Dynamic Level 3:
   - feedbackId = ArticleFeedback.addFeedback(articleId, commentId, locale)
```

### Example 3: Complex Cross-Module Dependency
```
TicketComment Creation:
- Needs: ticketId (from Ticket module)
- Needs: agentId (from Agent module)
- Needs: ticket must have department (from Department module)

Dependency Chain:
Department (Independent) 
    ↓
Agent (Needs Department)
    ↓
Ticket (Needs Agent + Department)
    ↓
TicketComment (Needs Ticket + Agent)
```

---

## 8. API Reference Structure

Each API has response handlers for different HTTP status codes:

```json
"apis": {
  "operationName": {
    "200": {          // Success response
      "param1": "generator_ref",
      "param2": "static_value"
    },
    "422": {          // Validation error response
      "param1": "generator_ref",
      "param2": "static_value"
    },
    "404": {          // Not found response
      "param1": "generator_ref"
    }
  }
}
```

**Why multiple status codes?**
- Test both success and failure scenarios
- Each status code may have different parameter requirements
- Helps in comprehensive test coverage

---

## 9. Quick Reference: Creating New Generators

### Step 1: Identify Entity Type
- Is it independent? → Use static generators
- Does it depend on other entities? → Use dynamic generators

### Step 2: Map Dependencies
- What other entities must exist first?
- Do they exist in same module or different module?
- What are their IDs/properties needed?

### Step 3: Create Generators
```json
{
  "apis": {
    "operationName": {
      "200": {
        "requiredParam1": "reference_to_generator",
        "requiredParam2": "reference_to_generator"
      }
    }
  },
  "generators": {
    "paramGenerator1": [{
      "type": "dynamic|static",
      "value": ["for_static"] | "other_properties_for_dynamic"
    }]
  }
}
```

### Step 4: Handle Multi-Level Dependencies
- If Generator B needs output from Generator A
- Set `name` in Generator A for easy reference
- Use `$generator_name.value` in Generator B params

---

## 10. Namespacing Guide

### Module Naming Conventions
- Portal modules: `portal.ModuleName.operation` or just `ModuleName.operation`
- Support modules: `support.ModuleName.operation`

### Example:
```json
"generatorOperationId": "portal.Solution.listAllArticles"
"generatorOperationId": "support.Ticket.getTicket"
"generatorOperationId": "Solution.listAllArticles"  // Assumes current namespace
```

---

## 11. Testing Dependencies

### Before creating a generator, ask:
1. ✅ What entities must exist before this one?
2. ✅ Are these entities in same module (use `#/generators/`) or different module (use `../`)?
3. ✅ What IDs/properties do I need from those entities?
4. ✅ Are there multiple levels of dependencies? (Chain them correctly)
5. ✅ Should I handle multiple HTTP status codes?
6. ✅ Are there any static values that configure the dynamic generation?

---

## 12. Common Mistakes to Avoid

❌ **Mistake 1**: Circular dependencies
- A depends on B, B depends on A → Will fail

✅ **Solution**: Always have at least one independent (static) entity at the start

---

❌ **Mistake 2**: Wrong module reference path
- Using `../WrongName/` instead of correct module path

✅ **Solution**: Check actual folder names in api-data-generators

---

❌ **Mistake 3**: Wrong dataPath extraction
- Using `$.data.id` instead of `$.response.body:$.data[*].id`

✅ **Solution**: Follow pattern: `$.response.body:path.to.array[*].field`

---

❌ **Mistake 4**: Forgetting to set `name` in dependent generators
- Generator 1 outputs data but Generator 2 can't reference it

✅ **Solution**: Set `"name": "reference_name"` in Generator 1 for Generator 2 to use

---

## 13. Quick Lookup: Module Dependencies

### Portal Modules Depend On:
- `ArticleFeedback` → depends on `Solution` (article IDs)
- `ArticleComment` → depends on `Solution` (article IDs)
- `Thread` → depends on `Community` (thread IDs)

### Support Modules Depend On:
- `Ticket` → depends on `Agent`, `Department`, `Contact`
- `TicketComment` → depends on `Ticket`, `Agent`
- `Article` → depends on `Product` (optional)
- Most entities → depend on `Organization/Account` (root entity)

---

## Summary Formula

For any new test data generator, follow this formula:

```
New Entity = 
  Static Values (Config, Status, etc.)
  + Dynamic References to Parent Entities
  + API Call with those references
  + Response Data Extraction (dataPath)
```

When requirements change or new features are added, trace dependencies:
1. What does this entity need to exist?
2. What entities need this entity?
3. Update accordingly in test_data_generation_configurations.json
